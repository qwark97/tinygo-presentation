# Hello, TinyGo!
And other fun embeded stuff

Marcin Plata
4 November 2022

marcin.plata@softwaremind.com

## Agenda
- What is TinyGo project?
- Used hardware
- The *fun*
    - Target: the light
    - Realization
    - Final result 

.image images/gopher.png 300 300

## What is TinyGo?

##
<!--
    * jak widnieje na stronie głównej - tinygo to compailer, który pozwala produkować binarki do małych miejsc
    * powstał w 
    * ma swoje zastosowanie do systemów embeded, do webassembly ale mozna za jego pomocą tworzyć tez "zwykłe" programy
    * golang w tinygo to ten sam golang co w zwykłym kompilatorze
    * wspiera niemalze wszystkie funkcjonalnosci co zwykłe go z zastrzezeniem ze tutaj istotna jest tez docelowa platforma
-->

.background images/tinygo-homepage.png

## For example
<!--
    * klasyczne "hello world", wybudowane przy uzyciu standardowego kompilatora oraz tinygo
    * warto zwrócić uwagę na rozmiary binarek:
        - klasyczna to prawie 2MB
        - tinygo to niespełna 30KB
    * Całość ma jednak swoją cenę
-->

.code hello_world.go

Standard Go
```
$ go build -o go-hello ./hello_world.go
```

TinyGo
```
$ tinygo build -o tinygo-hello ./hello_world.go
```
<br>
Comparition

.image images/binaries-comparition.png 80 _

## Should we then use it on PROD?
<!--
    * krótka odpowiedz - absolutnie nie
    * wybudowanie trywialnego programu w tinygo trwa wielokrotnie dłuzej niz w standardowym go i jest ogólnie cięzszą operacją
-->

**Efficiency**
<br>
Go

.image images/time-go-build.png 45 1000

TinyGo

.image images/time-tinygo-build.png 45 1000


## Should we then use it on PROD?
<!--
    * tinygo zostało stworzone w konkretnym celu i nie jest nim zastąpienie standardowego go
    * przede wszystkim tinygo ma wprowadzić Go na microcontrollery, a całość działa na tyle dobrze ze od 2020 roku jest projektem oficjalnie sponsorowanym przez Google   
-->

**Purpose**

.image images/scope.png

## How does it work beneath?
<!--
    * ogólnie, kompilator jest napisany bezposrednio w Go natomiast bazuje na LLVM'ie
    * jako ze się na tym nie znam, a nie chcialbym Was wprowadzić w błąd to podrzucam link do dokumentacji, która zainteresowanym wytłumaczy jak to wszystko działa
-->

.link https://tinygo.org/docs/concepts/compiler-internals/

.image images/internals.png 500 450

## Installation
<!--
    * prosta, generalnie wystarczy zastosować się do instrukcji
    * musi byc obecne Go
    * spod linku nalezy wybrac instrukcję odpowiadającą systemowi operacyjnemu
    * następnie trzeba wykonać kroki związane z mikrokontrolerem którego bedziemy uzywac
    * jak to często bywa, dokumentacja nie zawsze jest na 100% poprawna więc drobne umiejętności administratorskie 
    mogą być przydatne
-->

- Go must be available
- Follow the instructions:

.link https://tinygo.org/getting-started/install/

- Choose further steps based on the used microcontroller:

.link https://tinygo.org/docs/reference/microcontrollers/

<br>
<br>
<br>

_Debugging skills for used OS might be usefull_...

## About microcontrollers
<!--
    * tinygo wspiera znaczną ilość mikrokontrolerów
    * niektóre są wspierane w pełni, niektóre częściowo
    * lista w widoczna na gifie dostępna pod linkiem
-->

.link https://tinygo.org/docs/reference/microcontrollers/

.image images/microcontrollers.gif 500 600

## Used hardware
<!--
    * a skoro mowa o hardware'rze to ta prezentacja wykorzystuje płytkę ESP8266 - NodeMCU v3
    * płytka wygląda jak na obrazku
    * fajny sprzęt, ma moduł wifi, zasilanie oraz flashowanie moze się odbywać poprzez USB
    * stosunkowo dużo pinów, a całość można spinać bez potrzeby lutowania
-->

**ESP8266 - NodeMCU**

.image images/esp8266.png 570 1000

## Used hardware
<!--
    * obsługa tej płytki z perspektywy TinyGo wygląda w taki sposób
    * jest wsparcie dla podstaw czyli GPIO (general purpose input outpu), to dobrze 
    * jest UART czyli komunikacja szeregowa, okej
    * mimo że płytka posiada wifi to tinygo nie obsługuje... niedobrze
    * jest to o tyle ważne że połaczenie po sieci było by najbardziej naturalne 
      jako forma komunikacji
    * trudno, TinyGo tego nie obsługuje ale od czego są eksperymenty
    * i to powiedziawszy, przejdzmy od teorii do praktyki
-->

**From TinyGo perspective**

.image images/esp-interfaces.png 545 540
 
## The fun
<!--
    * biurko przy którym pracuję ma z tyłu listwę led
    * listwa może być sterowana pilotem przez podczerwień (POKAZAĆ PILOT)
    * cel jest taki, żeby w proces sterowania listwą wpiąć mikrokontroler i zyskać 
    nowe możliwości w kontekście sterowania światłem
-->

.image images/led-desk.jpeg 545 840

## Fulfilled prerequisites

- Installed TinyGo
- Installed additional stuff for the microcontroller
- Installed VSCode extension (ID: tinygo.vscode-tinygo)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

_All further activities performed on Linux_

## hello_world.go
<!--
    * omówienie kodu linia po linii (o "machine" zaraz powiem więcej)
-->

.code esp/hello_world/main.go

## hello_world.go
<!--
    * dzięki wtyczce o której wspominałem, VSCode kojarzy odpowiednią paczkę "machine"
    * w moim przypadku wygląda ona mniej więcej tak
    * definiuje wszystkie funkcjonalnosci związane z konkretnym mikrokontrolerem 
    zaimplementowane przez zespół TinyGo
-->

.image images/machine-package.gif

## hello_world.go
<!--
    * mamy kod źródłowy
    * wiemy już o co chodzi z paczką "machine"
    * czas zflashować płytkę
    * operacja jest prosta i szybka - znacznie szybsza niż analogiczny kod w 
    C zflashowany przy użyciu ArduinoIDE
-->

.image images/first-flashing.gif 550 1000

## hello_world.go
<!--
    * output z tinygo dostarcza podstawowych informacji n.t płytki i tutaj widać 
    go dokładniej
-->

.image images/first-flashing.png 550 1000

## hello_world.go
<!--
    * sam rezultat tego kodu prezentuje się w taki sposób. Płytka miga
-->

.image images/blinking.gif 550 700

