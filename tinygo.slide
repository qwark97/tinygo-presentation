# Hello, TinyGo!
And other fun embeded stuff

Marcin Plata
4 November 2022

marcin.plata@softwaremind.com

## Agenda
- What is TinyGo project?
- Used hardware
- The *fun*
    - Target: the light
    - Realization
    - Final result 

.image images/gopher.png 300 300

## What is TinyGo?

:    * jak widnieje na stronie głównej - tinygo to kompilator, który pozwala produkować binarki do małych miejsc
:    * powstał w 2019 roku (a przynajmniej wtedy był pierwszy release)
:    * ma swoje zastosowanie do systemów embeded, do webassembly ale mozna za jego pomocą tworzyć tez "zwykłe" programy
:    * golang w tinygo to ten sam golang co w zwykłym kompilatorze
:    * wspiera niemalze wszystkie funkcjonalnosci co zwykłe go z zastrzezeniem ze tutaj istotna jest tez docelowa platforma

.image images/tinygo-homepage.png 575 _

## For example

:    * klasyczne "hello world", wybudowane przy uzyciu standardowego kompilatora oraz tinygo
:    * warto zwrócić uwagę na rozmiary binarek:
:        - klasyczna to prawie 2MB
:        - tinygo to niespełna 30KB
:    * Całość ma jednak swoją cenę

.code src/hello_world.go

Standard Go
```
$ go build -o go-hello ./hello_world.go
```

TinyGo
```
$ tinygo build -o tinygo-hello ./hello_world.go
```
<br>
Comparition

.image images/binaries-comparition.png 80 _

## Should we then use it on PROD?

:    * krótka odpowiedz - absolutnie nie
:    * wybudowanie trywialnego programu w tinygo trwa wielokrotnie dłuzej niz w standardowym go i jest ogólnie cięzszą operacją

**Efficiency**
<br>
Go

.image images/time-go-build.png 45 1000

TinyGo

.image images/time-tinygo-build.png 45 1000


## Should we then use it on PROD?

:    * tinygo zostało stworzone w konkretnym celu i nie jest nim zastąpienie standardowego go
:    * przede wszystkim tinygo ma wprowadzić Go na microcontrollery, a całość działa na tyle dobrze ze od 2020 roku jest projektem oficjalnie sponsorowanym przez Google   


**Purpose**

.image images/scope.png

## How does it work beneath?

:    * ogólnie, kompilator jest napisany bezposrednio w Go natomiast bazuje na LLVM'ie
:    * jako ze się na tym nie znam, a nie chcialbym Was wprowadzić w błąd to podrzucam link do dokumentacji, która zainteresowanym wytłumaczy jak to wszystko działa


.link https://tinygo.org/docs/concepts/compiler-internals/

.image images/internals.png 500 450

## Installation

:    * prosta, generalnie wystarczy zastosować się do instrukcji
:    * musi byc obecne Go
:    * spod linku nalezy wybrac instrukcję odpowiadającą systemowi operacyjnemu
:    * następnie trzeba wykonać kroki związane z mikrokontrolerem którego bedziemy uzywac
:    * jak to często bywa, dokumentacja nie zawsze jest na 100% poprawna więc drobne umiejętności administratorskie 
:    mogą być przydatne


- Go must be available
- Follow the instructions:

.link https://tinygo.org/getting-started/install/

- Choose further steps based on the used microcontroller:

.link https://tinygo.org/docs/reference/microcontrollers/

<br>
<br>
<br>

_Debugging skills for used OS might be usefull_...

## About microcontrollers

:    * tinygo wspiera znaczną ilość mikrokontrolerów
:    * niektóre są wspierane w pełni, niektóre częściowo
:    * lista w widoczna na gifie dostępna pod linkiem


.link https://tinygo.org/docs/reference/microcontrollers/

.image images/microcontrollers.gif 500 600

## Used hardware

:    * a skoro mowa o hardware'rze to ta prezentacja wykorzystuje płytkę ESP8266 - NodeMCU v3
:    * płytka wygląda jak na obrazku
:    * fajny sprzęt, tani (ok. 30zł), ma moduł wifi, zasilanie oraz flashowanie moze się odbywać poprzez USB
:    * stosunkowo dużo pinów, a całość można spinać bez potrzeby lutowania


**ESP8266 - NodeMCU**

.image images/esp8266.png 570 1000

## Used hardware

:    * obsługa tej płytki z perspektywy TinyGo wygląda w taki sposób
:    * jest wsparcie dla podstaw czyli GPIO (general purpose input outpu), to dobrze 
:    * jest UART czyli komunikacja szeregowa, okej
:    * mimo że płytka posiada wifi to tinygo nie obsługuje... niedobrze
:    * jest to o tyle ważne że połaczenie po sieci było by najbardziej naturalne 
:      jako forma komunikacji
:    * trudno, TinyGo tego nie obsługuje ale od czego są eksperymenty
:    * i to powiedziawszy, przejdzmy od teorii do praktyki


**From TinyGo perspective**

.image images/esp-interfaces.png 545 540
 
## The fun

:    * biurko przy którym pracuję ma z tyłu listwę led
:    * listwa może być sterowana pilotem przez podczerwień (POKAZAĆ PILOT)
:    * cel jest taki, żeby w proces sterowania listwą wpiąć mikrokontroler i zyskać 
:    nowe możliwości w kontekście sterowania światłem


.image images/led-desk.jpeg 545 840

## Fulfilled prerequisites

:   * rozpoczęcie prac zaczynamy od takiego stanu początkowego

- Installed TinyGo
- Installed additional stuff for the microcontroller
- Installed VSCode extension (ID: tinygo.vscode-tinygo)
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

_All further activities performed on Linux_

## hello_world.go

:    * omówienie kodu linia po linii (o "machine" zaraz powiem więcej)


.code src/hello_world/main.go

## hello_world.go

:    * dzięki wtyczce o której wspominałem, VSCode kojarzy odpowiednią paczkę "machine"
:    * w moim przypadku wygląda ona mniej więcej tak
:    * definiuje wszystkie funkcjonalnosci związane z konkretnym mikrokontrolerem 
:    zaimplementowane przez zespół TinyGo


.image images/machine-package.gif

## hello_world.go

:    * mamy kod źródłowy
:    * wiemy już o co chodzi z paczką "machine"
:    * czas zflashować płytkę
:    * operacja jest prosta i szybka - znacznie szybsza niż analogiczny kod w 
:    C zflashowany przy użyciu ArduinoIDE


.image images/first-flashing.gif 550 1000

## hello_world.go

:    * output z tinygo dostarcza podstawowych informacji n.t płytki i tutaj widać 
:    go dokładniej


.image images/first-flashing.png 550 1000

## hello_world.go

:    * sam rezultat tego kodu prezentuje się w taki sposób. Płytka miga
:    * okej, nasze hello world działa
:    * co dalej?


.image images/blinking.gif 550 700

## Outside signal

:    * dokumentacja mówi, że wifi na płytce nie jest wspierane przez TinyGo
:    * nie mniej jednak nie zaszkodzi nam poeksperymentować, wykorzystując możliwości
:    czy to golanga samego w sobie czy też tinygo jako takiego


.image images/esp-interfaces.png 545 540

## Cgo

:    * przykładem funkcjonalności w go, która może pomóc, a częściowo działa w tinygo 
:    jest Cgo
:    * Cgo to funkcjonalność, która pozwala paczkom golangowym dokonywać wywołań funkcji 
:    napisanych C


.link https://go.dev/blog/cgo

.image images/cgo.png 515 _

## Cgo

:    * samo wykorzystanie Cgo wygląda taki sposób
:    * komentarz, który jest nad 'import "C"' jest interpretowany jako kod C
:    * do samych funkcji z C można się odwoływać poprzez tą importowaną pseudo paczkę
:    * z ciekawostek to pozbycie się importu paczki "fmt" odchudziło binarkę która robi 
:    tylko hello world z 1.8MB do 1.2MB


.code src/c_hello_world/main.go

.image images/c_hello.png

## Cgo

:    * w naszym wypadku, kod, który mógłby być użyteczny wygląda tak
:    * jest to wycinek z kodu, który już wykorzystywałem na tych płytkach 
:    * stąd wiem, że za jego pomocą powinno być możliwe podpięcie się do wifi
:    * niestety, kod w C mnie w tym przypadku pokonał
:    * mimo researchu i wielu eksperymentów, nie udało mi się tego skompilować poza Arduino IDE
:    * w związku z tym, choć teoretycznie takie rozwiązanie było by możliwe, musiałem odpuścić
:    * jeśli ktoś kto dobrze się czuje w C wie jak można tutaj coś podziałać to proszę o kontakt
:    * okej, C nie wypaliło to może jednak jest jakaś możliwość zrobić to bezpośrednio w TinyGo


.image images/wifi.gif 

## ESP-AT Driver

:   * zrobiłem kolejny research, i link po linku doszedłem do jakiejś propozycji
:   * polega ona na tym aby wykorzystać sterownik dedykowany do obsługi wifi dla ESP8266

.image images/wifi-github-issue.png

## ESP-AT Driver

:   * to rozwiązanie wykorzystuje komunikację szeregową i teoretycznie powinno pozwolić na połączenie się 
:   do wifi
:   * haczyk jest taki, że wymaga odpowiedniego firmware'u
:   * no to okej, skoro wymaga to trzeba go zainstalować

.image images/espat.png

## ESP-AT Driver

:   * po dłuuugim researchu, udało mi się znaleźć odpowiednie pliki i odpowiednie instrukcje
:   * sam proces flashowania wygląda na to że się powiódł, nie dostałem przynajmniej żadnych błędów
:   * uruchomiłem też na tym firmwarze przykład hello_world, wszystko śmiga

.image images/firmware-flashing.gif 550 1000

## ESP-AT Driver

:   * skoro miałem firmware, to bazując na przykładach które znalazłem stworzyłem odpowiedni kod
:   który powinien sprawić że płytka połączy się do wifi
:   * wygląda to mniej więcej tak (i omówić co się dzieje)

.code src/go_wifi/main.go

## ESP-AT Driver

:   * no a tutaj są pozostałe funkcje (i omówić co się dzieje)
:   * dane do sieci oczywiście w eksperymentach poprawiłem

.code src/go_wifi/main.go /START OMIT/,/END OMIT/

## ESP-AT Driver

:   * no a tak wygląda zflashowanie tego kodu
:   * standardowa komenda ale dodajemy dodatkowe dwie flagi
:   * -serial uart , mówi który serial output ma być użyty
:   * -monitor enables serial monitor
:   * jak widać niestety całość nie działa
:   * program pada na etapie potwierdzenia że istnieje komunikacja z płytką
:   * dlaczego tak się dzieje? niestety nie wiem. 
:   * To może być kwestia samej płytki, kwestia sterownika, kwestia firmware'u, ja mogłem zrobić błąd na którymś z tych etapów
:   * Trudno powiedzieć
:   * Faktem jest, że komunikacja w ten sposób nie zadziała

.image images/go_wifi.gif _ 1000

## We have a problem...

:   * trudno myśleć o jakimś ciekawym zastosowaniu płytki jeśli nie można się z nią skontaktować
:   * bez komunikacji jedyne co można zrobić to zaprojektować jedno zachowanie i tyle
:   * więc, skoro rozsądne (reasonable) sposoby interakcji nie zadziałały, spróbujmy czegoś dziwnego

.image images/meme.jpg

## Let's heat it

:   * podczas przeglądania sterowników dla tinygo zauważyłem coś takiego: sterownik dht


.image images/dht.png

## Let's heat it

:   * jest mi on znany, ponieważ już go używałem na tej płytce. Co prawda w C ale wciąż
:   * więc wpadłem na pomysł - nie udało mi się osiągnąć zdalnej komunikacji 
:   * ale może będę w stanie wpłynąć na zachowanie płytki za pomocą temperatury

.image images/c_dht(1).png 250 520
.image images/c_dht(2).png 270 520


## Let's heat it

:   * skoro tak, to zróbmy to
:   * trochę pokodowałem i rezultat prezentuje się następująco
:   * tak wygląda kod który pobiera temeraturę (omówić linia po lini i wskazać ze olewam błędy tu)

.code src/temp/main.go /START_PART1 OMIT/,/END_PART1 OMIT/

## Let's heat it

:   * a tak wygląda funkcja do czytelnego printowania temperatury
:   * nie bezzasadnie możecie spytać - Marcin, czemu w taki sposób tworzysz wiadomość, dlaczego nie użyłeś e.g. fmt.Sprintf
:   * pamiętacie jak mówiłem w kontekście cgo, że pozbycie się paczki fmt zmniejszyło binarkę z 1.8MB do 1.2MB
:   * cóż, ta paczka jest na tyle duża, że dla mojej płytki jest za duża. Stąd konieczność robienia rzeczy inaczej
:   * takie życie, embeded rządzi się swoimi prawami

.code src/temp/main.go /START_PART2 OMIT/,/END_PART2 OMIT/

## Let's heat it

:   * co ważne, kod który zrobiłem domyślnie nie zadziała z paczką "machine" dedykowaną dla mojej płytki
:   * jest tak dlatego, że jedna z funkcji sterownika "dht", oczekuje od paczki "machine" wartości, których ta nie dostarcza
:   * dodatkowo, nie mogę po prostu podmienić UART1 na UART0 które występuje dla ESP8266, bo "moja" wartość nie ma takich metod
:   * więc co w takiej sytuacji mogę zrobić?

.image images/thermometer-err.png

## Let's heat it

:   * mogę załozyć, że mogę żyć bez wyłączenia przerwań i po prostu wywalić te wywołania
:   * czy to najlepsze rozwiązanie? nie wiem
:   * czy działa? działa

.image images/thermometer-comment.png

## Let's heat it

:   * z perspektywy hardware'u wygląda to natomiast tak
:   * na tym zdjęciu widzimy sam termometr
:   * proste urządzenie z nienajlepszą dokładnością ale jest wystarczające

.image images/thermometer.jpg 550 _

## Let's heat it

:   * jest połączone z płytką w taki sposób
:   * żółty kabel (wire) to zasilanie (power supply) 3V
:   * niebieski to uziemienie
:   * zielony to podpięcie do PINu który pozwala na odczyt temperatury

.image images/connection.jpg 580 _

## Let's heat it

:   * czy to działa? 
:   * jak możemy zobaczyć na gifie, tak, działa
:   * początkowa temperatura zaczyna się powoli podnosić w momencie, w którym wkładam termomentr do ręki i go rozgrzewam
:   * a to oznacza, że jest to sposób na sterowanie zachowaniem płytki

.image images/solo_temp_measurement.gif _ 1000

## Action - reaction

:   * skoro wiemy, że sterowanie działa, jak może wyglądać software, który to wykorzysta
:   * zrobiłem coś takiego
:   * część pierwsza opisać co się dzieje

.code src/temp_trigger/main.go /START_PART1 OMIT/,/END_PART1 OMIT/

## Action - reaction

:   * część druga opisać co się dzieje
:   * funkcja prettyTempPrintln jest taka jak wczesniej

.code src/temp_trigger/main.go /START_PART2 OMIT/,/END_PART2 OMIT/

## Action - reaction

:   * wykonanie tego kodu prezentuje się w taki sposób
:   * gdy zaczynam ogrzewać termometr i temperatura przez niego wykrywana przekracza 30 stopni
:   * wtedy zapala się lampka
:   * gdy temperatura spadnie ponizej 30 stopni, lampka gaśnie
:   * super, skoro mamy sposób sterowania i odpowiednią logikę która to obsłuży możemy iść dalej
:   * kolejnym i ostatnim krokiem w tej historii będzie doprowadzenie do stanu, gdzie płytka 
:   na bazie temperatury będzie sterowała listwą ledową na moim biurku

.image images/temp_trigger.gif

## Illuminate

.link https://www.makeuseof.com/tag/connect-led-light-strips-arduino/

:   * tym razem zaczniemy od elektroniki
:   * nie będę wchodził za mocno w szczegóły natomiast całość jest bazowana na takim diagramie

.image images/diagram.png

## Illuminate

:   * na żywym sprzęcie wygląda to tak
:   * tutaj jest "motherboard for prototipes"
:   * widzimy rezystory, tranzystory i termomentr

.image images/motherboards.jpg 550 1000

## Illuminate

:   * a to jest źródło zasilania dla listwy ledowej
:   * płytka może wygenerować max 5V
:   * to urządzenie pozwala jako input wpiąć zasilacz 12V
:   * na wyjściu teoretycznie powinno być max 5V ale kiedyś coś spaliłem i jest 10V 
:   * i na szczęście (luckily) - my potrzebujemy 12V ale 10V jest wystarczająco

.image images/power-supply.jpg 880 _

## Illuminate

:   * połączenia do samej płytki wyglądają natomiast następująco
:   * red, green, blue oraz black są powiązane ze sterowaniem taśmą led
:   * fioletowy, pomarańczowy i brązowy to połączenie termometru

.image images/wires-connections.jpg 580 _

## Illuminate

:   * teraz kod
:   * generalnie jest to to co widzieliśmy wcześniej, z tym że 
:   zamiast tylko zapalić lampkę po przekroczeniu "tresholda" to jeszcze uruchamia taśmę
:   * tutaj definiujemy nowe piny, które odpowiadają tym, które były połączone na poprzednich zdjęciach


.code src/led_strip/main.go /START_DECLARATION OMIT/,/STOP_DECLARATION OMIT/

## Illuminate

:   * następnie funkcja main
:   * jak wcześniej z tym, że nowe piny potrzebują konfiguracji
:   * gdy zadziała trigger wołana jest odpowiednia funkcja

.code src/led_strip/main.go /START_MAIN OMIT/,/STOP_MAIN OMIT/

## Illuminate

:   * a same funkcje wyglądają tak
:   * to jest najprostszy sposób działania
:   * ten sposób po prostu odpala wszystkie kolory na maksymalną jasność
:   * teoretycznie powinno dać się też tym sterować ale uznałem, że to już jest poza zakresem
:   * może ktoś z Was będzie chciał to zmodyfikować i improve

.code src/led_strip/main.go /START_TRIGGER OMIT/,/STOP_TRIGGER OMIT/

## Illuminate?
:   * i teraz, najważniejsze pytanie - czy to działa?
:   * have we reached our goal?

.image images/terrifying.gif 500 600

## Illuminate!
:   * yep, it works!
:   * by warming up the thermometer, we are able to trigger the led strip to turn on
:   * and also - which isn't on the clip - turn off
:   * a to wszystko z wykorzystaniem tinygo i płytki esp8266

.image images/illuminate.gif 500 _

## Summary

 * Use proper tools to your tasks
 * __TinyGo rocks!__
 * Wires are important

:   * najważniejsze jest wybranie płytki zgodnej z oczekiwaniami
:   * jak głównym celem jest jakiś projekt, wtedy płytka powinna być taka żeby go obsłużyc
:   * jak celem jest zabawa z konkretnym językiem, wtedy płytka powinna być do niego dopasowana
:   * przykładowo, do zabawy z tinygo płytki ESP są beznadziejne

:   * samo tinygo jest fantastyczne. Łatwe w obsłudze, szybkie i przede wszystkim pozwala tworzyć logikę w go
:   * to ogromne uproszczenie gdy ktoś chce się bawić z mikrokontrolerami a nie zna / nie chce się uczyć C
:   * jasne, sam projekt jest młody i ma pewne problemy wieku dziecięcego
:   * ale prężnie się rozwija (is dynamically developing) i nie tylko dobrze się go używa ale stwarza okazję do kontrybucji w nim samym

:   * last but not least
:   * do zabawy z elektroniką trzeba cóż poznać elektronikę - nie tylko zasady działania prądu
:   * również istotne jest poznanie sposobów działania mikrokontrolerów, używanych protokołów, wykorzystywanych praktyk itp.
:   * jako że całe to otoczenie mocno działa na open sourcie, to umiejętności takie jak
:     budowanie, kompilowanie czy debuggowanie mogą być bardzo przydatne

:   * and that's it. I hope you enjoyed this presentation. And if you have any questions you can ask it now
:     or later on teams and I will try to answer it